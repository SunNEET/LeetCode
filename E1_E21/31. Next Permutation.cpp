class Solution {
    // 直接上其實不太好想到, 網路上找到一個例子還不錯
    // 有串array = [6,5,4,8,7,5,1]
    // 首先當然是從後面開始看, 但1跟5互換反而會變小
    // 8,7,5,1之間調換也沒有效果, 也都是越換越小, 此時也注意到8,7,5,1是遞減的
    // 如果想要找到下一個排列, 找到遞增的位置是關鍵
    // 因為在這裡才可以使其增長得更大
    // 於是找到了4, 顯而易見4過了是5而不是8或者7更不是1
    // 因此就需要找出比4大, 但在這些大數裡面最小的值, 並將其兩者調換
    // 那麼整個排列就成了：6 5 5 8 7 4 1
    // 這時還沒結束, 還要把5後面的那串遞減數列都變成遞增才行
    // 這樣才會是最小的情況
    
public:
    void nextPermutation(vector<int>& nums) {
        // 從個位數開始比, 所以自然是從後面開始看
        int i = nums.size() - 1, k = i;
        
        // i用來找出遞增的開頭, 也就是nums[i-1]<nums[i]的位置
        while (i > 0 && nums[i-1] >= nums[i])
            i--;
        // 找出後面那串裡, 比 遞增的開頭 大的最小值
        // 因為後面已經是遞減, 我從最後面找回來
        // 只要第一個滿足的就會是當前最小的了
        // i--完指向目前開頭, k用來找出我們的target
        // i==0的用意是針對整串數列已經是遞減(也就是最大的排列), i已經到起點
        // 這樣的話直接靠後面的處理把整串弄回遞增(也就是最小的排列)
        // 有個小問題是這樣i的值會不對(下面的i是有假設減過1移到遞增開頭的)
        // 所以用else處理, 這邊的寫法應該可以再優化
        if (i > 0) { 
            i--;
            while (nums[k] <= nums[i])
                k--;
            swap(nums[i], nums[k]);
        } else {
            i--;
        }
        // 把後面那串弄成遞增, 因為已經是排序好的遞減, 所以從兩側向內, 頭尾互換就好
        for (int j=i+1, k=nums.size()-1; j<k; j++, k--)
            swap(nums[j], nums[k]);
        
    }
};